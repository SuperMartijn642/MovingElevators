plugins {
    id "eclipse"
    id "idea"
    id "java-library"
    id "net.minecraftforge.gradle" version "6.0.25"
    id "org.spongepowered.mixin" version "0.7.+"
    id "me.modmuss50.mod-publish-plugin" version "0.5.2"
}

version = mod_version + "-forge-" + minecraft_suffix
group = maven_group
base.archivesName = mod_id

java.toolchain.languageVersion = JavaLanguageVersion.of(java_target)

println("Java: " + System.getProperty("java.version") + " JVM: " + System.getProperty("java.vm.version") + "(" + System.getProperty("java.vendor") + ") Arch: " + System.getProperty("os.arch"))

// Keep parameter names when compiling
compileJava.options.compilerArgs.add '-parameters'

repositories {
    flatDir { dirs "libs" }
    maven { url "https://www.cursemaven.com" }
    exclusiveContent {
        forRepository {
            maven { url = "https://api.modrinth.com/maven" }
        }
        filter { includeGroup "maven.modrinth" }
    }
    maven { url = "https://repo.spongepowered.org/maven" }
}

dependencies {
    // Forge
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
    // SpongePowered Mixin
    annotationProcessor "org.spongepowered:mixin:0.8.5:processor"

    // Core library
    implementation fg.deobf("curse.maven:supermartijn642s-core-lib-454372:${core_library_file}")
    // Config library
    implementation fg.deobf("curse.maven:supermartijn642s-config-lib-438332:${config_library_file}")

    // Rubidium
    compileOnly fg.deobf("curse.maven:rubidium-574856:${rubidium_file}")
    // Embeddium
    compileOnly fg.deobf("curse.maven:embeddium-908741:${embeddium_file}")
    // Sodium
    compileOnly fg.deobf("something:sodium:forge-0.6.0-alpha.3+mc1.20.1")
    // Oculus
    compileOnly fg.deobf("curse.maven:oculus-581495:${oculus_file}")
    // Iris
    compileOnly fg.deobf("something:iris:forge-1.20.1-1.8.0-snapshot+mc1.20.1-local")

    // Just Enough Items
//    runtimeOnly fg.deobf("curse.maven:jei-238222:${just_enough_items_file}")
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir "src/generated/resources" }

processResources {
    inputs.property "version", version

    // Replace the mod version
    Map<String, ?> copyProperties = project.properties.clone() as Map<String, ?>
    //noinspection UnnecessaryQualifiedReference
    var matcher = java.util.regex.Pattern.compile("[^.0-9]").matcher(copyProperties.mod_version as String)
    if (matcher.find())
        copyProperties.mod_version = copyProperties.mod_version.substring(0, matcher.start()) + "+" + copyProperties.mod_version.substring(matcher.start())

    filesMatching(["META-INF/mods.toml", "modid.mixins.json", "pack.mcmeta"]) {
        expand copyProperties
    }

    exclude "**/*.pdn"

    rename "^modid.mixins.json\$", "${mod_id}.mixins.json"
    rename "^icon.png\$", "${mod_id}.png"
}

minecraft {
    mappings channel: "official", version: minecraft_version

    accessTransformer = file("src/main/resources/META-INF/accesstransformer.cfg")

    runs {
        configureEach {
            workingDirectory file("run")

            property "forge.logging.markers", "REGISTRIES"

            mods {
                //noinspection GroovyAssignabilityCheck
                source sourceSets.main
            }
        }

        client {
        }

        server {
        }

        data {
            args "--mod", mod_id
            args "--all"
            args "--output", file("src/generated/resources/")
            args "--existing", layout.buildDirectory.file("/data_resources").map { it.asFile }.get()
        }
    }
}

// MixinGradle Settings
mixin {
    add sourceSets.main, "${project.mod_id}.mixins.refmap.json"
    config "${project.mod_id}.mixins.json"
}

// Rename the IntelliJ run configs
gradle.taskGraph.whenReady {
    tasks.genIntellijRuns.doLast {
        def configDir = it.getRunConfigurationsFolder().get().getAsFile()
        minecraft.runs.each {
            //noinspection GroovyAssignabilityCheck
            def configFile = new File(configDir, it.getUniqueFileName() + ".xml")
            if(configFile.exists()){
                def xml = new groovy.xml.XmlSlurper().parse(configFile)
                //noinspection GrUnresolvedAccess
                xml.configuration.@name = "Forge " + it.name.capitalize()
                configFile.withWriter { groovy.xml.XmlUtil.serialize(xml, it) }
            }
        }
    }
}

tasks.register('prepareDataResources', Sync) {
    from file("src/main/resources")
    into layout.buildDirectory.dir("/data_resources")
    inputs.property "version", version

    // Replace the mod version
    Map<String, ?> copyProperties = project.properties.clone() as Map<String, ?>
    //noinspection UnnecessaryQualifiedReference
    var matcher = java.util.regex.Pattern.compile("[^.0-9]").matcher(copyProperties.mod_version as String)
    if (matcher.find())
        copyProperties.mod_version = copyProperties.mod_version.substring(0, matcher.start()) + "+" + copyProperties.mod_version.substring(matcher.start())

    filesMatching(["META-INF/mods.toml", "modid.mixins.json", "pack.mcmeta"]) {
        expand copyProperties
    }

    exclude "**/*.pdn"

    rename "^modid.mixins.json\$", "${mod_id}.mixins.json"
    rename "^icon.png\$", "${mod_id}.png"
}

// Run prepareDataResources before prepareRunData
tasks.configureEach {
    if (it.name == "prepareRunData" || it.name == "prepareRunDataCompile")
        it.dependsOn "prepareDataResources"
}

// Force the jar to be reobfuscated
jar.finalizedBy('reobfJar')

publishMods {
    file = jar.archiveFile
    displayName = "${mod_name} ${mod_version} for Forge ${minecraft_suffix.substring(2)}"
    version = project.version
    //noinspection UnnecessaryQualifiedReference
    type = me.modmuss50.mpp.ReleaseType.of(publishing_release_type.toUpperCase())
    changelog = file("changelog.md").text
    modLoaders.add("forge")
    maxRetries = 2

    curseforge {
        accessToken = System.getenv("CURSEFORGE_TOKEN")
        projectId = curseforge_project_id
        if (!curseforge_required_dependency_ids.isEmpty())
            curseforge_required_dependency_ids.split(" ").each it::requires
        if (!curseforge_optional_dependency_ids.isEmpty())
            curseforge_optional_dependency_ids.split(" ").each it::optional
        publishing_game_versions.split(" ").each minecraftVersions::add
        clientRequired = true
        serverRequired = true
    }

    modrinth {
        accessToken = System.getenv("MODRINTH_TOKEN")
        projectId = modrinth_project_id
        displayName = "${mod_name} ${mod_version}"
        if (!modrinth_required_dependency_ids.isEmpty())
            modrinth_required_dependency_ids.split(" ").each it::requires
        if (!modrinth_optional_dependency_ids.isEmpty())
            modrinth_optional_dependency_ids.split(" ").each it::optional
        publishing_game_versions.split(" ").each minecraftVersions::add
    }
}

// Rename the 'publishMods' task
tasks.publishMods.group = "other"
tasks.register("publishAll") {
    group = "publishing"
    dependsOn(tasks.publishMods)
}
